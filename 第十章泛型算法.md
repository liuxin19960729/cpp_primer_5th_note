 # 第十章泛型算法
 ## 10.1 概述
 ```cpp
#inlude<algorithm>
#include<numeric> 数值泛型算法

一般情况下
算法遍历两个迭代器的指定范围

auto result= find(begin,end,val);范围内是否包含val值
返回 迭代器(第一个与之匹配)

result==end true 表示返回失败没有找到

find 操作的是迭代器 我们可以使用任何容器进行查找

list
array:
int ia[]={1,2,3};
auto result= find(begin(ia),end(ia),3);

find() 我么可以给定 任何合法的范围 进行查找

```
#### 算法如何工作
#### 迭代器算法不依赖于容器
#### 算法依赖元素类型操作
```
find() 要求元素支持 ==操作
```
 #### 10.1 练习
 [code](./codes/chapter9/10_1.cpp)
 
 #### 关键概念
 ```
 泛型算法永远不会执行容器操作 他只会执行在迭代器上
 ``` 
 ## 10.2 初识泛型算法
 ```
 接收输入的算法总是接收 前后的两个迭代器 表示范围
 ```
 ### 10.2.1 只读算法
 ```cpp
 find
 count 
 accumulate   #include<numric>

int sum =accumulate(cbegin,cend,0);
0 表示初始值
第三个参数表四 使用元素的那个+ 运算符 和 返回值的类型
```
#### 算法和元素类型
```
序列总能转化到第三个类型 或匹配
int 
   long ,long long  ,double float 等能转化到int


例：
string str=accumulate(cben,cend,string("));
string 类型定义 + 操作符 所以 可以调用accumulate


note:
只读不改变的算法最好使用 cbegin 和 cend
```
#### 操作两个序列的算法
```cpp
bool equal() 确定两个序列是否相等
equal(cbegin1,cend1,cbengin2)

只要元素 支持==就可以

equal 有一个假设 
cbegin2 的容器至少==cbegin1
```
 #### 10.2.1 练习
 [code](./codes/chapter9/10_2_1.cpp)
 ### 10.2.2 写容器元素的算法
 ```
 算法不会执行容器操作,因此他们自身不可能改变容器的大小

 fill(begin,end.0)将元素重置为0

```
 #### 算法不检查写操作
 ```
 fill_n(begin,vec.size(),0)
 迭戈参数必须确保传入个数安全
 ```
 #### 介绍back_inserter
 ```
 插入迭代:向容器添加元素的迭代器

 #include<iterator>
 back_inserter 接收指向容器的一个引用

 vector<int> vec;
 auto it=back_inserter();
 *it=10; 向 vec添加一个元素


fill_n(back_iterator(vec),10,0); 向vec添加10个元素
```
#### 拷贝算法
```
传入的序列至少要和输入序列一样多
int a[]={1,2,3};
int a2[sizeof(a)];
auto ret=copy(begin(a1),end(a1),a2);//a2 至少要和 a1一眼多
将a1拷贝到a2


replace(begin,end,0,52);
    当一个值为0替换为第二个值

replace_copy(begin,end,back_iterator(ivec),0,42);
原来的容器值不该变
ivec包含 ilst的拷贝 不过 原来lst值为0变为了42
```
 #### 10.2.2 练习
 [code](./codes/chapter9/10_2_2.cpp)

 #### 10.2.3 重排容器元素的算法
 ```
 sort(begin,end)
   < 排序

sort() 将重复的元素排列成 相邻元素 
iterator=unique(begin,end)将不重复的放在vector开始的部分
  unique 返回元素重复开始的地方

ivec.earse(iteartor,ivec.end());//删除重复区域
```
#### 使用unique
```
note:迭代器不能操作容器
```
#### 使用容器删除真正的元素
## 10.3 定制操作
### 10.3.1 向算法传递函数
``` 
bool fun(const stringng s1,const string){
    return s1<s2;
}
sort(begin,end,fun)
```
#### 排序算符
```
stable_sort
稳定排序算法
稳定排序维持元素原油的顺序

word 按长度大小排序 同样大小 按字典排序
```
#### 10.3.2 lambda表达式
```
find_if(begin,end,predict)
```
#### 介绍lambda
```
我么可以向算法传递可调用对象

可调用对象(args) 调用对象

可调用对象实现方式
1.函数 函数指针
2.lambda
3.重载调用运算符的类
auto f= [capture list](parameter list)->returen tyupe{}

[capture list]:
     所在函数的局部变量列表

auto a=[]{}；
编译器推断 空形参 返回 void的函数

lambda 返回 return,并且未指定类型则返回void
```
#### 向lambda传递参数
```

```
