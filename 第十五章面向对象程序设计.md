# 第十五章面向对象程序设计
```
抽象 
继承
动态绑定
```
### 15.1 OOP 概述
#### 继承
```
基类
派生类

在c++语言中
基类将类型相关的函数与派生类不做直接的继承 而是被区分对待
基类需要他适用于某个版本 则是虚函数 virtual
c++11
允许派生类显示的注明它将使用那个成员含糊去改写基类虚函数

动态绑定
使用同一段代码 分贝处理基类对象和派生类对象


note:
c++ 语言中当我们使用基类的引用和指针调用虚函数则发生动态绑定

```
## 15.2 定义基类和派生类
### 成员函数与继承
```
派生类可以继承其基类的成员
派生类需要对这些提供自已的定义以覆盖

虚函数
   希望派生类来覆盖
   动态绑定:根据对象不用执行的函数不同
   
   基类中声明一个函数是虚函数 则派生类该函数也隐式的也是虚函数
```
#### 访问控制与继承
```
派生类 可以访问基类 的public protected 成员
而不能访问private成员

```
### 15.2.2定义派生类
#### 派生类中的虚函数
```
若派生类未覆盖虚函数 则虚函数的行为类似其他普通成员

c++11 新标准 允许派生类显示的注明它成员函数覆盖其虚函数
在函数后面显示的添加override
```
#### 派生类对象及派生类基类的类型转换
```
c++ 标准并没有明确规定对象内存如何分布
Quote []
bulk_quote  []

在一个对象中继承自基类部分的派生类的内存不一定时连续存储

派生类到基类的转换 编译会隐式的执行派生类到基类的转换

note:
派生类对象 是含有基类对象的组成部分
```
#### 派生类构造函数
```
派生类不能直接初始化基类成员
派生类必须使用基类的构造函数来初始化基类部分

note:
每个类控制自己成员的初始化过程

派生类可以通过初始化列表来调用基类构造来初始化

note:
  先初始化基类 在初始化派生类


派生类的作用域前台在基类的作用域之内
```
#### 关键概念:遵循基类的接口
```
每个类负责各自的接口
想要域类成员交互必须使用接口交互

派生类不能直接初始化基类成员

派生类应该遵循基类个构造函数 通过初始化列表调用基类构造函数初始化
```
### 继承与静态成员
### 派生类的声明
```
class A;

class A :public B; //错误派生类声明包含继承列表

class A; 告诉编译存在一个类 A 但是编译器不知道类的成员和内存布局

class A;  声明但是未定义
```
#### 被用作基类的类
```
如果我们使用某个基类 ,这个基类必须被定义
```
#### 防止继承的发生
```
c++11
class A final{

}


A 是 final的类  不能被继承
```
### 15.2.3 类型的转换和继承
```
我们可以将基类的指针或引用绑定到派生类对象上

A{

}

B :A{

}

B a;
A & c=a;

c 可能代表的是基类对象 也可能是派生类对象
```
#### 静态类型和动态类型
#### 不存在基类向派生类的隐式类型转换
#### 对象之间不存在类型转换
## 15.3 虚函数
```
我们使用基类的指针和引用调用虚函数会执行动态绑定
当我们执行的时候才知道是那个函数
```
#### 派生类中的虚函数
```
当基类是某个类是虚函数 派生类也是虚函数

派生类中的虚函数 返回类型和基类必须匹配,形参也要严格匹配
```
#### final 和 override 说明符
```
c++11
overiride 关键字 来说明派生类中的虚函数
如果该函数并没有覆盖虚函数则编译时期报错


void f() const final;
final  不允许该函数被覆盖

final 和 override 说明符出现在形参之后(包括 const ,const&,&&)

```
#### 虚函数和默认实参
```
虚函数也可以拥有默认实参

如果我们使用基类指针和引用调用函数 默认实参使用基类的默认实参
当然 指针 和引用可能是派生类
  默认实参是编译期间确定 是静态类型的
```
#### 回避虚函数机制
```
使用作用域 调用基类函数
p->A::fun()
该调用将在 编译期间解析
```
## 15.4 抽象基类
#### 纯虚函数
```
声明纯虚函数 只能在类内部使用
virtual void a()=0;
```
#### 含有纯虚函数的类是抽象基类
```
我们不能直接创建抽象类的对象
```
## 15.5 访问控制和继承
#### 受保护成员
```
protected 派生类共享 对其他类不共享

public:


private:

派生类的成员和有元只能通过派生类对象访问受保护的成员,对基类不存在任何的访问权限

有元函数 类 成员函数 只能访问对应的类的私有等变量 和派生 基类没有任何关系  
```
#### 公有 私有 受保护继承
#### 友元与继承
```
友元关系不能传递,友元关系不能继承

有元访问权限由 类控制

```
#### 该变个别成员的可访问性
```cpp
using 可以改变成员的可访问性

class A{
private :
    int a;
    void fun();
}


class B :publilc A{
    protected:
        using int A::a;
    private:
        using A::fun;
}

using 该变了成员的可访问性
using 可以将类的直接和间接基类的成员 变为可访问

B 中 using 的访问权限 是 放在那个权限下面决定的

note:
派生类只能为那些他可以访问的名字提供using
public 和 protectd 的才能使用 using 
使用using 可以重新在派生类分配权限
```
#### 默认继承保护级别
```
class 默认派生级别是私有
struct 默认派生级别是公有
```
### 15.6 继承中的作用域
```
派生域的作用域嵌套在基类作用域之内

编译器只能在当前作用域的名字 和 自己外面作用域找名字
外面作用域不能向里面去找名字
```
#### 在编译时进行名字查找
```
对象 引用  指针 的静态类型决定了那些成员可见

```
#### 名字冲突与类型
```
派生类中有和基类同名的成员
则会隐藏基类的成员
```
#### 通过作用域运算符来隐藏成员
```
A::mem;
:: 作用域运算符覆盖原来的查找规则
指示编译从 A类的作用域开始查找

最佳实践
除了覆盖继承而来的虚函数之外派生类最好不要重新定义基类名字
```
#### 关键字名字的查找和继承
```
p->mem  or obj.mem

1.确定静态类型

2.静态类型查找
  --->基类-->基类-->顶端
  查找不到 编译器报错

3.找到成员 确认当前mem 的调用是否合法

    虚函数:
      指针或者引用调用  编译器产生代码 将在运行时确定

    不是虚函数 编译器将通过对象非指针或引用进行调用  
```
#### 一如既往,名字查找优先类型检查
```
内层作用域的函数不会重载声明外部的函数

如果派生类里面定义的函数 会隐藏其基类同名的函数或成员
```
#### 虚函数与作用域
#### 通过基类调用隐藏的虚函数
#### 覆盖重载的函数
```
函数无论是虚函数都能被重载

派生类可以从中函数0个和多个实例
using A:函数名

无需覆盖直接把函数所有冲在添加到派生作用域中
要求
必须是派生类可访问的
```
## 15.7 构造和拷贝控制
### 15.7.1 虚析构函数
```
virtual ~A(){} 把析构函数定义为虚拟函数
使他能够正确执行析构函数

让编译知道析构函数是虚拟函数

析构含糊的虚拟属性也是被继承的

```
#### 虚拟函数析构函数将阻值合成移动操作
```
基类需要许析构函数对派生类参数影响:
 即使使用 派生类使用 =default ,也不会合成移动操作
```
#### 15.7.2 合成拷贝控制与继承
```
基类和派生类合成构造函数 赋值运算 析构函数

构造函数：
    对类成员的初始化
赋值
  对类成员的复制
析构
    对类成员的销毁

```
#### 派生类中删除的拷贝控制与基类的关系
### 15.7.4 继承的构造
```
c++11
类不能继承默认 拷贝  移动构造函数

class A:public B{
pulbic:
    using B::B;//将编译器在当前作用域下面可见

}
编译生成了一个对应的构造函数
 using B::B;
 编译器生成了 B里面的构造函数 

生成了这种形式的构造函数
A(params):B(args);

```
### 继承构造函数的特定
```
using 构造函数不能修改构造函数的访问级别

和基类的构造函数的访问级别保持一致

using 语句不能指定explicit 或 constexpr

using 构造参数 继承 和基类保持一致


基类构造含有实参 实参并不会被继承


A(int a =100,int b=200,int c);

using A::A
编译器 会构建

B(int a):B(a);
B(int a,int b):B(a,b);
B(int a,int b,int c):B(a,b,c);

当派生类存在和继承的相同的构造函数 则不会被继承

默认 拷贝 移动 不会被构造
```
## 15.8 容器与继承
```
容器存放继承体系对象 必须采用间接存储的方式进行存储

class A{

}

class B:public A{

}


vector<A> avec;

A a;
avec.push_back(a);
B b;
a.vec.push_back(b);只能把A对象不分存储进去

vector<B> bvec;
A a;
bvec(a);//错误 不呢将A转成B对象

派生类存入基类的容器 派生类部分的数据就会被切掉
```
#### 在容器总存放(智能)指针而非对象
```
容器中存放继承关系的对象时通常存放指针

vector<shared_ptr<A>> avec;
avec.push_back(make_shared<B>())

...

```