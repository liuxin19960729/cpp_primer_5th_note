# 第十五章面向对象程序设计
```
抽象 
继承
动态绑定
```
### 15.1 OOP 概述
#### 继承
```
基类
派生类

在c++语言中
基类将类型相关的函数与派生类不做直接的继承 而是被区分对待
基类需要他适用于某个版本 则是虚函数 virtual
c++11
允许派生类显示的注明它将使用那个成员含糊去改写基类虚函数

动态绑定
使用同一段代码 分贝处理基类对象和派生类对象


note:
c++ 语言中当我们使用基类的引用和指针调用虚函数则发生动态绑定

```
## 15.2 定义基类和派生类
### 成员函数与继承
```
派生类可以继承其基类的成员
派生类需要对这些提供自已的定义以覆盖

虚函数
   希望派生类来覆盖
   动态绑定:根据对象不用执行的函数不同
   
   基类中声明一个函数是虚函数 则派生类该函数也隐式的也是虚函数
```
#### 访问控制与继承
```
派生类 可以访问基类 的public protected 成员
而不能访问private成员

```
### 15.2.2定义派生类
#### 派生类中的虚函数
```
若派生类未覆盖虚函数 则虚函数的行为类似其他普通成员

c++11 新标准 允许派生类显示的注明它成员函数覆盖其虚函数
在函数后面显示的添加override
```
#### 派生类对象及派生类基类的类型转换
```
c++ 标准并没有明确规定对象内存如何分布
Quote []
bulk_quote  []

在一个对象中继承自基类部分的派生类的内存不一定时连续存储

派生类到基类的转换 编译会隐式的执行派生类到基类的转换

note:
派生类对象 是含有基类对象的组成部分
```
#### 派生类构造函数
```
派生类不能直接初始化基类成员
派生类必须使用基类的构造函数来初始化基类部分

note:
每个类控制自己成员的初始化过程

派生类可以通过初始化列表来调用基类构造来初始化

note:
  先初始化基类 在初始化派生类


派生类的作用域前台在基类的作用域之内
```
#### 关键概念:遵循基类的接口
```
每个类负责各自的接口
想要域类成员交互必须使用接口交互

派生类不能直接初始化基类成员

派生类应该遵循基类个构造函数 通过初始化列表调用基类构造函数初始化
```
### 继承与静态成员
### 派生类的声明
```
class A;

class A :public B; //错误派生类声明包含继承列表

class A; 告诉编译存在一个类 A 但是编译器不知道类的成员和内存布局

class A;  声明但是未定义
```
#### 被用作基类的类
```
如果我们使用某个基类 ,这个基类必须被定义
```
#### 防止继承的发生
```
c++11
class A final{

}


A 是 final的类  不能被继承
```
### 15.2.3 类型的转换和继承
```
我们可以将基类的指针或引用绑定到派生类对象上

A{

}

B :A{

}

B a;
A & c=a;

c 可能代表的是基类对象 也可能是派生类对象
```
#### 静态类型和动态类型
#### 不存在基类向派生类的隐式类型转换
#### 对象之间不存在类型转换
## 15.3 虚函数
```
我们使用基类的指针和引用调用虚函数会执行动态绑定
当我们执行的时候才知道是那个函数
```
#### 派生类中的虚函数
```
当基类是某个类是虚函数 派生类也是虚函数

派生类中的虚函数 返回类型和基类必须匹配,形参也要严格匹配
```
#### final 和 override 说明符
```
c++11
overiride 关键字 来说明派生类中的虚函数
如果该函数并没有覆盖虚函数则编译时期报错


void f() const final;
final  不允许该函数被覆盖

final 和 override 说明符出现在形参之后(包括 const ,const&,&&)

```
#### 虚函数和默认实参
```
虚函数也可以拥有默认实参

如果我们使用基类指针和引用调用函数 默认实参使用基类的默认实参
当然 指针 和引用可能是派生类
  默认实参是编译期间确定 是静态类型的
```
#### 回避虚函数机制
```
使用作用域 调用基类函数
p->A::fun()
该调用将在 编译期间解析
```
## 15.4 抽象基类
#### 纯虚函数
```
声明纯虚函数 只能在类内部使用
virtual void a()=0;
```
#### 含有纯虚函数的类是抽象基类
```
我们不能直接创建抽象类的对象
```
## 15.5 访问控制和继承
#### 受保护成员
```
protected 派生类共享 对其他类不共享

public:


private:

派生类的成员和有元只能通过派生类对象访问受保护的成员,对基类不存在任何的访问权限

有元函数 类 成员函数 只能访问对应的类的私有等变量 和派生 基类没有任何关系  
```
#### 公有 私有 受保护继承
#### 友元与继承
```
友元关系不能传递,友元关系不能继承

有元访问权限由 类控制

```
#### 该变个别成员的可访问性
```cpp
using 可以改变成员的可访问性

class A{
private :
    int a;
    void fun();
}


class B :publilc A{
    protected:
        using int A::a;
    private:
        using A::fun;
}

using 该变了成员的可访问性
using 可以将类的直接和间接基类的成员 变为可访问

B 中 using 的访问权限 是 放在那个权限下面决定的

note:
派生类只能为那些他可以访问的名字提供using
public 和 protectd 的才能使用 using 
使用using 可以重新在派生类分配权限
```
#### 默认继承保护级别
```
class 默认派生级别是私有
struct 默认派生级别是公有
```
### 15.6 继承中的作用域
```

```