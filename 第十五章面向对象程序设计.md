# 第十五章面向对象程序设计
```
抽象 
继承
动态绑定
```
### 15.1 OOP 概述
#### 继承
```
基类
派生类

在c++语言中
基类将类型相关的函数与派生类不做直接的继承 而是被区分对待
基类需要他适用于某个版本 则是虚函数 virtual
c++11
允许派生类显示的注明它将使用那个成员含糊去改写基类虚函数

动态绑定
使用同一段代码 分贝处理基类对象和派生类对象


note:
c++ 语言中当我们使用基类的引用和指针调用虚函数则发生动态绑定

```
## 15.2 定义基类和派生类
### 成员函数与继承
```
派生类可以继承其基类的成员
派生类需要对这些提供自已的定义以覆盖

虚函数
   希望派生类来覆盖
   动态绑定:根据对象不用执行的函数不同
   
   基类中声明一个函数是虚函数 则派生类该函数也隐式的也是虚函数
```
#### 访问控制与继承
```
派生类 可以访问基类 的public protected 成员
而不能访问private成员

```
### 15.2.2定义派生类
#### 派生类中的虚函数
```
若派生类未覆盖虚函数 则虚函数的行为类似其他普通成员

c++11 新标准 允许派生类显示的注明它成员函数覆盖其虚函数
在函数后面显示的添加override
```
#### 派生类对象及派生类基类的类型转换
```
c++ 标准并没有明确规定对象内存如何分布
Quote []
bulk_quote  []

在一个对象中继承自基类部分的派生类的内存不一定时连续存储

派生类到基类的转换 编译会隐式的执行派生类到基类的转换

note:
派生类对象 是含有基类对象的组成部分
```
#### 派生类构造函数
```
派生类不能直接初始化基类成员
派生类必须使用基类的构造函数来初始化基类部分

note:
每个类控制自己成员的初始化过程

派生类可以通过初始化列表来调用基类构造来初始化

note:
  先初始化基类 在初始化派生类


派生类的作用域前台在基类的作用域之内
```
#### 关键概念:遵循基类的接口
```
每个类负责各自的接口
想要域类成员交互必须使用接口交互

派生类不能直接初始化基类成员

派生类应该遵循基类个构造函数 通过初始化列表调用基类构造函数初始化
```
### 继承与静态成员
### 派生类的声明
```
class A;

class A :public B; //错误派生类声明包含继承列表

class A; 告诉编译存在一个类 A 但是编译器不知道类的成员和内存布局

class A;  声明但是未定义
```
#### 被用作基类的类
```
如果我们使用某个基类 ,这个基类必须被定义
```
#### 防止继承的发生
```
c++11
class A final{

}


A 是 final的类  不能被继承
```
### 15.2.3 类型的转换和继承
```

```