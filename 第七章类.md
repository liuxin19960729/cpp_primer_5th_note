# 第七章类
```
数据抽象:接口,实现的分离编程技术

接口:
    用户能执行的操作
接口实现:
    类的数据成员
    负责接口实现的函数体
    以及定义类的各种私有函数

```
## 7.1 定义抽象的数据类型
### 7.1.1 设计Sales_data类
### 7.1.2 定义一个改进的Sales_data类
```
注意定义在class 内部的函数是inline 
```
#### const成员函数
```cpp
struct AA{
public:
    void cc() const{

    }
}
这里的const是默认修改了 this 指针,使this所指向这块区域的值不能修改
```
#### 类的作用域和成员函数
```
编译器 编译类

1.先变异成员声明,在编译程序函数
 (为什么成员写在函数后面也能被访问)

```
#### 在类的外部定义成员函数
```cpp
//必须要保持和申明一致包括后面的这个const
void AA::cc() const{

}

编译器根据AA 知道 cc函数在AA作用域内
```
#### 定义一个返回的this对象的函数
```
return *this;返回的是this的对象
```
### 7.1.3定义类相关的非成员函数
### 7.1.4 构造函数
```
构造函数不能被声明为const

由于在函数构造过程中需要向对象写入值,初始化值,当真正的构造完成
对象完全形成才能对对象使用const属性
```
#### 合成默认的构造函数
```
当我们的类没有显示的构造函数,编译器回为我们定义一个默认构造函数
```
#### 某些类不依赖默认的构造函数
#### =default 含义
```
AA()=default;
我们希望这个函数的作用完全等同于之前使用的默认构造函数

c++11;
=default 要求编译器生成默认构造函数
默认构造函数是inline
```
### 构造函数初始化列表
```

AA():xx(x),xxxx(){

}
```
#### 在函数体外部定义构造函数
```
AA::AA():xx(x),xxxx(){

}
```
### 7.1.5 拷贝构造和析构
## 7.2 控制与封装
#### clss 和 struct 关键字
```
struct 定义额类 默认 public
class 定义的类默认 private
```
### 7.2.1 有元
```
class{
    friend xxx（）；
}

有元不是类的成员也能访问类的private 成员

```
## 7.3 类的其他特性
### 7.3.1 类的成员在探
```cpp

class A{
  public:
     typedef xxx xx;
     uisng ss=sss;
}

类自定义类型的别名 可以和其他成员一样访问限制
public or private 的一种
```
#### 令成员做我内联
```
1,定义在类内部默认inline

inline void A::a(){

}
类外部使用inline 显示声明内联函数

注意 inline 相关的函数或成员函数放在头文件里面

```

#### 可变成数据成员
```
如果在 const的成员函数希望修改一个成员的值可以使用 
mutable 

mutable 修饰的成员 即使对象是const 也能进行修改
```
#### 类数据成员的初始值
```
c++11

class A{
    int a=0;
    int b{0};
    vector<int> c(10,1);
}
```
### 7.3.2 返回*this成员函数
#### 从const成员函数返回*this
```
返回的是 const 的引用
```
### 7.3.3 类类型
#### 类声明
### 7.3.4 有元在探
```
有元函数
有元类
有元类成员函数
函数重载有元
  函数名相同不代表就是这个函数
```
## 7.4 类的作用域
## 构造函数再探
```
note:
const or 引用成员变量必须初始化 
或默认初始化 或在初始化列表初始化,不能再构造函数体进行初始化
```
#### 成员初始化顺序
```
初始化列表的前后顺序不能够操作类成员的初始化顺序

类成员构造顺序是函数成员的声明顺序
```
#### 默认实参和构造函数
```
class A{
public:
    int a;
    A(int v=1):v(v){

    }
}
如果我们为构造参数每个都定义了默认的实参,则实际意义也定义了默认构造参数

```
## 7.5.2 委托构造函数
```cpp
c++11
把自己个构造的职责委托其他构造参数来做


class A{
public
    int a;
    int b;
    int c;
    A(int ia,int ib,int ic):a(ia),b(ib),c(ic){}
    //委托构造函数
    A():A(0,0,0){}
      //委托构造函数
    A(int ia):A(ia,0,0){}
      //委托构造函数
    A(int ia,int ib):A(ia,ib,0){}
}

执行顺序
当前构造函数初始化列表-->受委托构造函数初始列表-->当前函数函数的函数体-->受委托函数体

```
### 7.5.3 默认构造函数的作用
```
对象默认初始化 默认执行默认构造函数

默认初始化发生的情况

1.块的作用域 不使用任何值初始化
2.类里面的成员,并且使用默认构造
3.类类型在执行构造参数列表初始化,成员类没有在初始化列表

1.局部静态变量
2.数组初始化并且数组参数不够编译会回帮我使用默认创建


最佳实践:
在设计类的时候最好提供一个默认构造参数
```
#### 使用默认构造参数
```
Class cls();
上面的声明并不是争取的调用默认构造函数声明对象而是
声明一个 函数

Class cls;//调用默认构造函数生成对象
```
### 7.5.4 隐式的类型转换
```
自定义类的隐式转换机制

构造参数 只有接受一个实参我们称为转换构造参数
```
#### 抑制隐式转换
```
通过对构造函数使用 explicit 
编译器就不能自己通过构造函数找来构造必须显示构造

explicit 只对一个实参的构造产生有效
只能在类内声明
不要在类外声明
```
#### explicit 构造只能用于直接初始化
```
用explicit 指定构造函数只能使用,若要使用构造
函数只能显示直接构造

```
#### 转显示的使用构造
```
static_cast<Class>(xx);来调用当前构造函数转换
static_cast 指向显示的转换,会调用对应的构造参数创建这个类
```
### 7.5.5 聚合类
```
没有构造函数
所有成员public
没有基类,也没有virtual
没有类初始值
struct Class{
  int a;
  int b;
}

Class a={1,2};来进行初始化

注意初始化的顺序和成员顺序一样

如果初始化的值少于成员个数会被值初始化
```
### 7.5.6 字面常量类
```
字面量类必须含有constexpr函数成员
并且函数成员必须满足constexpr 的所有要求

1.字面类型聚合类,是字面值常量类
2.符合下面要求
  数据类型必须是字面值类型
  必须含有一个constexpr 构造函数
  成员存在初始值必须是常量表达式
  类必须使用默认析构 负责成员销毁

```
## 7.6 类的静态成员
#### 类的静态成员
```
类的静态成员和类关联在一起并不和对象关联在一起

静态成员的类型
  常量 指正 应用  类类型

静态成员函数和类绑定 不和对象绑定

由于 类里面的 const 的函数是 把 this 指针指定为const
由于静态函数和类是一起非对象所以静态函数不能是const类型


对象可以访问静态成员
也可以 类::xx访问


静态函数在外部定义不能使用static
static 只能在类内部使用

静态成员在类外部初始化
并且静态函数只能被定义一次
最好放在类的源码文件里


```
