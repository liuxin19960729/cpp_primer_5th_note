# 第十二章动态内存
```
全局对象:
    程序开始分配 程序结束 销毁
局部对象:
    进入程序快创建
    离开销毁
局部 static；
  第一次进入分配
  程序结束时销毁

动态分配对象:
  动态创建
  动态销毁
```
### 动态内存和智能指针
```cpp
new 
   分配内存空间
   返回指针
delete
   销毁动态对象指针
   释放与之关联的内存

智能指针:
  shared_ptr 允许多个指针指向同一个对象
  unique_ptr 独占指针对象
  weak_ptr 弱引用 指向shared_ptr 所管理的对象

  #include<memory>
```
### 11.1.1 shared_ptr 类
```
shared_ptr 也是模版
c++11

创建智能指针必须提供 指向的类型

shared_ptr<string> ptrstr; 保存一条空指针

通过解引用可以访问对象
pstr pstr->mem
```
#### shared_ptr 和 unique_ptr都支持的操作
```
空指针
shared_ptr<T> sp
unique_ptr<T> up

p 判断一指针是否属于空指针

*p 解引用

p->mem
p.get() 返回 p 保存的指针
        要小心使用 
        若智能指针释放其对象 指针所指向的对象也就消失

p和 q交换指针
swap(p,q) ;
p.swap(q);
```
#### 只合适shared_ptr 的操作
```
make_shared<T>(args);
        args 初始化对象
shared_ptr p(q)
      p是q的拷贝
      q cnt++;
p=q; 
   p cnt--  cnt==0 则会释放内存
   q cnt++

p.unique() p.use_count() ==1 返回 true
p.unse_count() 共享指针数
```
#### make_shared 函数
```cpp
#include<memory>
在动态内存总分配一个对象并且初始化它
make_shared(args)

shared_ptr<int> p=make_ptr<int>(0);
shared_ptr<string>=make_ptr<string>(10,c);

auto p=make_ptr<int>();
```
#### shared_ptr 的拷贝和赋值
```
auto p=mkake_shared<int>(42);//use_count=1
auto q(p) p q 有两个引用者

p=q
shared_ptr(q) 
   q都会 use_count++

离开作用域 或 关联的shared_ptr 被赋值为新对象则 use_count--;


一旦 use_count==0 则会释放内存

例
auto r=make_shared<int>(42);r=1
r=q;q usercount ++;
    r usercount --;
r此时指向的是另一个地址
```
#### shared_ptr 自动销毁锁管理的对象
```
析构函数
当 use_count ==0 则会在析构函数里面 delete 指针

例如

string 析构函数
会负责释放销毁分配存储字符的内存
```
#### shared_ptr 还会自动释放相关联的内存
``` cpp
shared_ptr<Foo> factor(T args){
    return make_shared<Foo>(args) 
}
1;
返回四拷贝构造 use_count=2;
离开范围 use_count=1;
所以返回对象是不会被销毁的


将share_ptr 存放在容器中 
重拍容器 cnt 不变
erase() 删除元素  调用析构函数 share_ptr cnt-1  cnt==0 销毁

note:将shard_ptr 放在容器 如果不在使用一定要将他使用erase进行删除
```
#### 使用动态生存期的类
```
程序使用动态生存周期的资源类
1.程序不知道自己需要使用多少对象
2.程序不知道所需对象的确定类型
3.程序不知道对象的准确类型
4.程序需要多个对象间的共享数据


note:
使用动态内存的原因是多个对象共享用一块内存区域

```
### 12.1.2 直接内存管理
#### 使用new 来动态分配和初始化对象
```
int *pi=new int;
默认情况下 动态分配的对象是默认初始化
类类型 使用默认构造初始化

string * ps=new string; 调用 string 空参构造
int *pi= new int ;未初始化构造

我们也可以使用直接初始化方式构造 
new int(10)

new vector<int>{1,2,3};


自己定义的类 会调用默认构造参数 或调用 制定参数的构造参数
内置对象 
new int() 初始化为0 
new int  系统随机分配值

c++11
auto  p1=new auto(obj) p1 指向一个和 obj类型相同的对象
auto p2=new auto(a,b,c) 错误 ()只能有单个初始化器

auto p=new auto(100);int leixng
obj 是string 则 p是 string *

编译器回根据值来推断
```
#### 动态分配const对象
```
new 分配const是合法的
const int * pci=new const int (1024);
const string *pcs=new const string;

需要动态分配的const必须进行初始化

```
#### 内存耗尽
```
当内存耗尽时 new 分配内存就可能失败

throw bad_alloc 异常

int *p2=new (nothrow) int;
 阻值抛出异常 当内存分配完会返回空指针

new(nothrow) 向new传递参数
  告诉new 不要抛出异常

#include<new>
bad_alloc
nothrow 
```
#### 释放动态内存
```
delete expression
delete p;
p指向 动态类型内存的指针 或 空指针
```
#### 指针值和delete
```
同一块区域不能释放多次
或是 对非 new 的区域进行释放

const int *cpi=new const int();
delete cpi ;释放静态const 区域
```
#### 动态对象的生存周期知道被释放为止
#### 小心动态内存非常容易管理错误
```
忘记
delete 就是我们说的内存泄露问题

已经释放 未将 ptr 设置为 nullptr

同一块内存区域释放两次
```
#### delete 之后重置指针值
### 12.1.3 shared_ptr 和 new 的结合使用
```
shared_ptr<double> p1;
shared_ptr<int>p2(new int(42));

shared_ptr 类是explicit
shared_ptr<int> p2=new int(42);//错误不能隐式转换
```
#### 定义和改变shared_ptr 的其他方法
```
shared_ptr<T> p(q);
  q必须new分配的指针

shared_ptr<T>p(u)从 unique_ptr 接管所有权 u设置为null

shared_ptr p(q,d);
  p接管q所指向对象的所有权 
  f 将调用d来代替delete

shared_ptr p(p,d)
   p 是p2的拷贝
   d来代替 delete

reset()
   p是唯一指向shared_ptr 指针会释放
p.reset(q) 
   p置位null 指针
   q指向 p 原来
p.reset(q,d)
  p 为null
  q为 p原来
  d 是 delete的调用函数
```
#### 不要混合使用普通指针和智能指针
#### 也不要使用get初始化另一个智能指针或指针指针赋值
```
sptr.get() 返回内置指针

note:
在代码不会delete 情况下使用get
千万注意不要使用 get() 返回的值错位另一另 shared_ptr 进行初始化
```
#### 其他的shared_ptr 操作
```
p.reset(new int())
与赋值类似
```
### 12.1.4 只能指针和异常
```

```