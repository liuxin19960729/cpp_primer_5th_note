# 第十二章动态内存
```
全局对象:
    程序开始分配 程序结束 销毁
局部对象:
    进入程序快创建
    离开销毁
局部 static；
  第一次进入分配
  程序结束时销毁

动态分配对象:
  动态创建
  动态销毁
```
### 动态内存和智能指针
```cpp
new 
   分配内存空间
   返回指针
delete
   销毁动态对象指针
   释放与之关联的内存

智能指针:
  shared_ptr 允许多个指针指向同一个对象
  unique_ptr 独占指针对象
  weak_ptr 弱引用 指向shared_ptr 所管理的对象

  #include<memory>
```
### 11.1.1 shared_ptr 类
```
shared_ptr 也是模版
c++11

创建智能指针必须提供 指向的类型

shared_ptr<string> ptrstr; 保存一条空指针

通过解引用可以访问对象
pstr pstr->mem
```
#### shared_ptr 和 unique_ptr都支持的操作
```
空指针
shared_ptr<T> sp
unique_ptr<T> up

p 判断一指针是否属于空指针

*p 解引用

p->mem
p.get() 返回 p 保存的指针
        要小心使用 
        若智能指针释放其对象 指针所指向的对象也就消失

p和 q交换指针
swap(p,q) ;
p.swap(q);
```
#### 只合适shared_ptr 的操作
```
make_shared<T>(args);
        args 初始化对象
shared_ptr p(q)
      p是q的拷贝
      q cnt++;
p=q; 
   p cnt--  cnt==0 则会释放内存
   q cnt++

p.unique() p.use_count() ==1 返回 true
p.unse_count() 共享指针数
```
#### make_shared 函数
```cpp
#include<memory>
在动态内存总分配一个对象并且初始化它
make_shared(args)

shared_ptr<int> p=make_ptr<int>(0);
shared_ptr<string>=make_ptr<string>(10,c);

auto p=make_ptr<int>();
```
#### shared_ptr 的拷贝和赋值
```
auto p=mkake_shared<int>(42);//use_count=1
auto q(p) p q 有两个引用者

p=q
shared_ptr(q) 
   q都会 use_count++

离开作用域 或 关联的shared_ptr 被赋值为新对象则 use_count--;


一旦 use_count==0 则会释放内存

例
auto r=make_shared<int>(42);r=1
r=q;q usercount ++;
    r usercount --;
r此时指向的是另一个地址
```
#### shared_ptr 自动销毁锁管理的对象
```
析构函数
当 use_count ==0 则会在析构函数里面 delete 指针

例如

string 析构函数
会负责释放销毁分配存储字符的内存
```
#### shared_ptr 还会自动释放相关联的内存
``` cpp
shared_ptr<Foo> factor(T args){
    return make_shared<Foo>(args) 
}
1;
返回四拷贝构造 use_count=2;
离开范围 use_count=1;
所以返回对象是不会被销毁的


将share_ptr 存放在容器中 
重拍容器 cnt 不变
erase() 删除元素  调用析构函数 share_ptr cnt-1  cnt==0 销毁

note:将shard_ptr 放在容器 如果不在使用一定要将他使用erase进行删除
```
#### 使用动态生存期的类
```
程序使用动态生存周期的资源类
1.程序不知道自己需要使用多少对象
2.程序不知道所需对象的确定类型
3.程序不知道对象的准确类型
4.程序需要多个对象间的共享数据


```