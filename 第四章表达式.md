# 第四章表达式
## 4.1基础
### 4.1.1基本概念
```
一元运算符:用于一个对象的运算符
   &取地址 *解引用 
二元运算符:用于两个对象的运算
  + == ...
三元运算符
```
#### 组合运算符和运算对象
#### 运算对象转换
#### 重载运算符
```
c++ 语言定义了内置类型和复合类型的运算对象所执行的操作

我们在定义类里面可以重新定义运算符实现的意义,这叫做重载运算符

note:
我们重载运算符可以实现但是运算符的优先级是不能改变的
```
#### 左值和右值
```cpp
左值:可以放在=的左侧
右值:不能放在=的左侧

int b=100;
int a=b+1;
   b是左值但是 b用于 =右侧所以 b用的是对象值
   a 用作=左侧 用的是 a的内存空间
左值可以用作右值
右值不能取当做左值


1.证明: = 左边左值 计算结果还是左值
int i = 100;
int b = 200;
int &c = (b = i);
c = 300;
cout << "i: " << i << endl;//100
cout << "b: " << b << endl;//300
cout << "c: " << c << endl;//300

2.
证明 并不能赋值给 int *类型的引用表明 右值,
右值其结果并不能指明自己是地址空间
int i = 100;
int *&pi = &i; //erro 

3.[] *ptr 迭代器解引用 的计算结果都是左值

4.++ -- 等操作结果是左值
  ++a --a 左值
    int a = 100;
    int b = (++a); //101
    先相加在返回 a(左值) 在=右边 取a值赋值给b 
  a++  a-- 右值 
    int a = 100;
    int b = (a++);
      编译器回编译为
      int temp =a;
      int b=a;
      a=temp+1;   


note:decltype()更具表达式的计算结果左值判断是否是&
decltype(++a) c=a;//++a运算结果左值 int & 类型
decltype(*p) c=a;//指针解引用结果是左值 引用

int a=10;
decltype(a) a的结果是10 所以不是引用
decltype((a)) 是引用 
```
### 优先级和结合律
```

```