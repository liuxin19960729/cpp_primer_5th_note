# 第二章变量和基本类型
## 2.1基本内置类型
```
c++定义了一套算数类型和空类型(void)
算数类型:
    字符
    整形
    布尔
    浮点
空类型:
    不对应具体的值,仅用于特殊场合
    例:用于函数不返回任何值时使用空类型
```
### 2.1.1算数运算符
```
算数运算符分为两类:整形和浮点型
c++标准规定了基本类型的最小占用位数

bool 未规定
char 8bits
wchar_t 16bits
char16_t unicode 字符  16bits
char32_t unicode 字符  32bits
short 16bits
int 16bits
long 32bits
long long 64bits (c++11)
float 6位有效数字
double 10位有效数字
long double 10位有效数字

c++标准规定 int>=short的位数
           long long >=long的位数


c++ 标准指定了浮点数有效位数的最小值,然而大多数的编译器实现了更加高的精度
float:1word(32bits)
double:2word(64bits)
long double(3or 4 word)
一般来说flaot 有7bit ,double 16bit 有效数字
long double 用于特殊需求硬件,具体实现不同精度不同


有效数:从左边第一个不为0的数开始计算
```
#### 内置类型的机器实现
```
byte:寻址的最小内存块
word:存储的基本单元
byte:8bits
word:32or64bits
```
#### 带符号和无符号类型
```
signed:负号 0 正数
unsigned 0 正数

整形
int short long long long 都是 signed 
unsigned int ,......都是无符号的
note: unsigned 是  unsigned int

字符型
char
signed char 
unsigned char

特别注意:
char 和 signed char 不一样
char 表示 singed char 或者 unsigned char 是由编译器决定的

```
#### 建议:如何选择类型
```
c++设计的标准之一是尽可能的接近硬件

选择类型的准则
1.明确知道不能是负数则选用unsigned类型
2.一般使用 int进行运算符,但范围超过int使用long long (64bits)
  short (16bits)
  int 最小(16bits)>=short
  long>=int 未了可移植性 防止 long ==int 最好使用 long long
3.在算数运算中不要使用 bool 或 char
  char 并不是 signed char ,更具不同机器和编译器而定
  如果需要不大的数 明确指定  unsigned char 或  signed char

4.浮点数运算选用double
  float 精度不够,double 和 double 的计算代价差不多
  long double 一般不需要 ,一般用于有特殊要求的硬件上  
```
#### 2.1.1节练习
[code](./codes/chapter2/2_1_1.cpp)

### 2.1.2 类型转换
```
bool b=42;//自动转换为true
int i=b;//b为true被转换为1

unsigned char cc=-1;//被转为255;


bool 0 false 否则 true


unsigned char =-1;
[1111,1111] =255;


signed char =256;//(隐式的从int 转换到singed char)
[1 0000 0000] 只能访问到[0000,0000] 前8位

257=[1 0000 0001]
signed char gg=(signed char)257;
gg=[0000 0001]
int ggint=gg;//1
std::cout << ggint << std::endl;//1


int i=42;
if(i){//编译器回将条件只转换为true

}

bool b=i;//b的值为1,若i的值为0 则吧的值为0



```
#### 建议无法预知和依赖的于实现的行为
```
程序应该避免依赖实现环境的行为
如果依赖环境,则程序的就不可移植

```
#### 含有无符号的表达式
```
int i=-42;
unsinged u=10;

i+i //
i+u // unsigned + signed 编译器回转换成无符号
 i转化为无符号的值
 (i+u)%2^32
 
-42   1.....1101 0110 
10             1010
  1111111......1 0 0000  =0xffffffe0=4294967264

4294967264%2^32== 4294967264


unsigned int u1=100,u2=200;
u2-u1==100;
u1-u2//保证是正数 


note:
for(unsinged i=100,i>=0;i--){

}
上面这种写法是错误写法,i是无符号 无符号计算还是无符号永远都大于0,这个循环是一个无限循环
```
#### 切勿带符号和无符号的进行混用
```
无符号和有符号进行计算,在计算期间有符号会被编译器隐式转换为无符号
```
#### 2.1.2练习
[code](./codes/chapter2/2_1_2.cpp)
### 3.1.3 字面值常量
```
每个字面值常量对应着一种数据类型
```
#### 整形和浮点数的字面值
```
整形
024 8进制 0开头
24 10进制
0x24 16进制 0x开头

note:
1.默认情况下10 进制的字面量是带符号的,8进制,16进制可能带符号也可能不带符号
2.10进制字面值的类型是int long long long 尺寸最小,并且类型能够容纳的下值

3.如果字面量最大数据类型都放不下将产生错误(long long 64bits)

8进制 16进制 int ,unsigned int , long , unsigned long ,long long ,unsigned long long ,那个容纳的下就是那个类型



浮点数:
浮点数的字面量默认是double,

double c=2e-3;//0.002  .002 等来表示浮点数的字面量
std::cout<<c<<std::endl;
```
#### 字符和字符串的字面量
```
'a' 字符字面量
"a" 字符串字面量

字符串的字面量实际就是字符构成的数组
"a"=={'a','\0'}

多行书写的字符串字面量
char *c="abc  "
        "sssss;
实际上上面的两个字符串是个整体
```
#### 转义序列
```
\n 换行
\\ \
\r 回车
\" "
\' '
\?
\a 报警响铃
\t 横向制表符
\v 纵向制表符

数字对应的是字符
\x  16进制数据
\ 8进制数据

例
std::cout << '\x64' << std::endl;
char d = 0x64;
std::cout << d << std::endl;
//output
d
d


note:
"\1234"  表示两个字符  '\123' 为一个字符  '4' 为一个字符
"\x1234" 表示一个字符但是每个字符占据8位 ,0x1234 16bit可能报错

```
#### 指定字面值的类型
```
L'a' wchar_t(16bits类型)
std::cout<<typeid(L'a').name()<<std::endl;//w

u8"Hi" utf-8字面量值

无符号整数类型
42ULL unsigned long long

0.001F float 单精度字面量值
std::cout<<typeid(3.0F).name()<<std::endl;//f

0.001L //long double
std::cout<<typeid(3.0L).name()<<std::endl;


指定字面量类型

字符和字符串
u char16_t unicode

U char32_t unicode
L  wchar_t

u8 utf-8 字符串常量


整形常量
u/U unsigned
l/L  long
ll/LL long long

浮点数字面值
f float
L long double


note:
整数
u 那么 字面量 unsigned int /unsigned long /unsigned long long 选择一个最小能匹配的类型

L long 字面量最小为long  
ll  long long  /unsigned long long 中的一种合适的类型

uL/uLL
ul:字面量的类型为  unsigned long or unsigned long long 一种类型

//最低类型为 unsigned long long 
std::cout<<typeid(1ULL).name()<<std::endl;
```
#### bool值和指针的字面值
```
bool字面值
true false 

指针字面值
nullptr
```
#### 2.1.3练习
[code](./codes/chapter2/2_1_3.cpp)


## 2.2变量
```
c++ 每个变量都有其数据类型
数据类型决定着变量所占内存大小和布局方式
```
### 2.2.1 变量定义
#### 什么是对象
```
对象是一块存储数据并具有某种类型的存储空间
```
#### 初始值
```
double price=100,discount=prince*0.16;
price 先定义,并用于后面的discount 初始化中

double cc=fun();
//先自行fun() 返回值对cc变量进行初始化

在c++中初始化可复制是完全不同的两个操作

初始出:在创建变量时赋予一个初值
赋值 把当前值擦除用于个新值来代替
```
#### 初始化列表
```
int a=0;
int a={0};
int a{0};
int a(9);


long double ld=2.111111;
int a{ld},b={ld}错误 初始化存在丢失信息的风险
int a(ld),b=ld;正确不会存在丢失信息风险

{} 在编译的时候会检查丢失是否信息
```
#### 默认初始化
```
如果定义变量没有指定值变量会默认初始化
1.函数体内的变量不会默认初始化为0
2.定义在函数体之外 全局变量 或 static 全局变量 会默认初始化为0


类的是否必须初始化有类来决定
```
#### 2.2.1 练习
[code](../cpp_primer_5th_note/codes/chapter2/2_2_1.cpp)