# 第二章变量和基本类型
## 2.1基本内置类型
```
c++定义了一套算数类型和空类型(void)
算数类型:
    字符
    整形
    布尔
    浮点
空类型:
    不对应具体的值,仅用于特殊场合
    例:用于函数不返回任何值时使用空类型
```
### 2.1.1算数运算符
```
算数运算符分为两类:整形和浮点型
c++标准规定了基本类型的最小占用位数

bool 未规定
char 8bits
wchar_t 16bits
char16_t unicode 字符  16bits
char32_t unicode 字符  32bits
short 16bits
int 16bits
long 32bits
long long 64bits (c++11)
float 6位有效数字
double 10位有效数字
long double 10位有效数字

c++标准规定 int>=short的位数
           long long >=long的位数


c++ 标准指定了浮点数有效位数的最小值,然而大多数的编译器实现了更加高的精度
float:1word(32bits)
double:2word(64bits)
long double(3or 4 word)
一般来说flaot 有7bit ,double 16bit 有效数字
long double 用于特殊需求硬件,具体实现不同精度不同


有效数:从左边第一个不为0的数开始计算
```
#### 内置类型的机器实现
```
byte:寻址的最小内存块
word:存储的基本单元
byte:8bits
word:32or64bits
```
#### 带符号和无符号类型
```
signed:负号 0 正数
unsigned 0 正数

整形
int short long long long 都是 signed 
unsigned int ,......都是无符号的
note: unsigned 是  unsigned int

字符型
char
signed char 
unsigned char

特别注意:
char 和 signed char 不一样
char 表示 singed char 或者 unsigned char 是由编译器决定的

```
#### 建议:如何选择类型
```
c++设计的标准之一是尽可能的接近硬件

选择类型的准则
1.明确知道不能是负数则选用unsigned类型
2.一般使用 int进行运算符,但范围超过int使用long long (64bits)
  short (16bits)
  int 最小(16bits)>=short
  long>=int 未了可移植性 防止 long ==int 最好使用 long long
3.在算数运算中不要使用 bool 或 char
  char 并不是 signed char ,更具不同机器和编译器而定
  如果需要不大的数 明确指定  unsigned char 或  signed char

4.浮点数运算选用double
  float 精度不够,double 和 double 的计算代价差不多
  long double 一般不需要 ,一般用于有特殊要求的硬件上  
```
#### 2.1.1节练习
[code](./codes/chapter2/2_1_1.cpp)

### 2.1.2 类型转换
```
bool b=42;//自动转换为true
int i=b;//b为true被转换为1

unsigned char cc=-1;//被转为255;


bool 0 false 否则 true


unsigned char =-1;
[1111,1111] =255;


signed char =256;//(隐式的从int 转换到singed char)
[1 0000 0000] 只能访问到[0000,0000] 前8位

257=[1 0000 0001]
signed char gg=(signed char)257;
gg=[0000 0001]
int ggint=gg;//1
std::cout << ggint << std::endl;//1


int i=42;
if(i){//编译器回将条件只转换为true

}

bool b=i;//b的值为1,若i的值为0 则吧的值为0



```
#### 建议无法预知和依赖的于实现的行为
```
程序应该避免依赖实现环境的行为
如果依赖环境,则程序的就不可移植

```
#### 含有无符号的表达式
```
int i=-42;
unsinged u=10;

i+i //
i+u // unsigned + signed 编译器回转换成无符号
 i转化为无符号的值
 (i+u)%2^32
 
-42   1.....1101 0110 
10             1010
  1111111......1 0 0000  =0xffffffe0=4294967264

4294967264%2^32== 4294967264


unsigned int u1=100,u2=200;
u2-u1==100;
u1-u2//保证是正数 


note:
for(unsinged i=100,i>=0;i--){

}
上面这种写法是错误写法,i是无符号 无符号计算还是无符号永远都大于0,这个循环是一个无限循环
```
#### 切勿带符号和无符号的进行混用
```
无符号和有符号进行计算,在计算期间有符号会被编译器隐式转换为无符号
```
#### 2.1.2练习
[code](./codes/chapter2/2_1_2.cpp)